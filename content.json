{"pages":[],"posts":[{"title":"Linux 如何配置静态 IP","text":"Linux 版本为 Ubuntu18.04 修改网络配置文件** 1vi /etc/netplan/50-cloud-init.yaml 修改为下面内容： 1234567891011121314network: ethernets: # 网卡名字 ens33: # 配置虚拟机静态 IP addresses: [192.168.48.139/24] dhcp4: no dhcp6: no # 网关 IP gateway4: 192.168.48.2 # 配置 DNS nameservers: addresses: [114.114.114.114, 8.8.8.8] version: 2 重启网络 1netplan apply","link":"/2020/04/06/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Linux%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"},{"title":"Linux 编译 OpenJDK8","text":"OpenJDK 有些组成部分是用 C++ 编写的，更多的代码则是使用 Java 自身实现的，因此编译这些 Java 代码需要用到一个可用的 JDK，官方称它为 Boot JDK。 如果编译 OpenJDK8，Boot JDK 可以是 OpenJDK7，也可以是 OracleJDK7，或者更早的版本。 准备工作 安装 Mercurial 1apt-get install mercurial 用 Mercurial 下载 1hg clone http://hg.openjdk.java.net/jdk8u/jdk8u 执行脚本 12cd jdk8u &amp;&amp;bash get_source.sh 开始编译 安装 Boot JDK 解压缩 1tar -zxvf zulu7.31.0.5-ca-jdk7.0.232-linux_x64.tar.gz 改名 1mv zulu7.31.0.5-ca-jdk7.0.232-linux_x64.tar.gz jdk7.0.232 配置用户环境变量 1vi /etc/profile 添加如下语句 1234567JAVA_HOME=/usr/local/java/jdk7.0.232JRE_HOME=/usr/local/java/jdk7.0.232PATH=$PATH:$JRE_HOME/bin:$JAVA_HOME/binexport JAVA_HOMEexport JRE_HOMEexport PATH 使用户环境变量生效 1source /etc/profile 测试是否安装成功 1234root@ubuntu:/usr/local/jdk8u-dev# java -versionopenjdk version \"1.7.0_232\"OpenJDK Runtime Environment (Zulu 7.31.0.5-CA-linux64) (build 1.7.0_232-b6)OpenJDK 64-Bit Server VM (Zulu 7.31.0.5-CA-linux64) (build 24.232-b6, mixed mode) 安装依赖 安装依赖12apt-get install build-essential unzip zip libx11-dev libxext-dev libxrender-dev \\libxtst-dev libxt-dev libcups2-dev libfontconfig1-dev libasound2-dev libfreetype6-dev 检查依赖 123456789101112131415161718192021bash configure====================================================A new configuration has been successfully created in/usr/local/jdk8u-dev/build/linux-x86_64-normal-server-releaseusing default settings.Configuration summary:* Debug level: release* JDK variant: normal* JVM variants: server* OpenJDK target: OS: linux, CPU architecture: x86, address length: 64Tools summary:* Boot JDK: openjdk version \"1.7.0_232\" OpenJDK Runtime Environment (Zulu 7.31.0.5-CA-linux64) (build 1.7.0_232-b6) OpenJDK 64-Bit Server VM (Zulu 7.31.0.5-CA-linux64) (build 24.232-b6, mixed mode) (at /usr/local/java/jdk7.0.232)* Toolchain: gcc (GNU Compiler Collection)* C Compiler: Version 7.4.0 (at /usr/bin/gcc)* C++ Compiler: Version 7.4.0 (at /usr/bin/g++)Build performance summary:* Cores to use: 1* Memory limit: 962 MB 编译即可 1make all 参考网址： How can i install jdk7 on ubuntu 18.04 lts 64bit JVM-Ubuntu18.04.1下编译OpenJDK8","link":"/2020/04/06/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Linux%E7%BC%96%E8%AF%91OpenJDK8/"},{"title":"如何理解 Java的反编译","text":"理解反编译前，先要知道编译，编译指把高级语言（Java)翻译成计算机可识别的二进制语言。那么反编译就是对程序的逆向分析 让我们一起动手试试吧，反编译下面的代码： 12345678public class Hello { public static void main(String[] args) { int i = 1; i = i++; // i = 1 int j = i++; // i = 2, j = 1 int k = i + ++i * i++; // i = 4, k = 2 + (3 * 3) }} 输入编译指令 1javac Hello.java 反编译指令 1javap -c Hello.class &gt; Hello.txt -c：指定文件名 &gt;：把反编译的内容输出 得到内容 12345678910111213141516171819202122232425262728Code:// int i = 1;0: iconst_1 // 1 -&gt; 栈顶1: istore_1 // 栈顶 -&gt; 局部变量（索引为1）// i = i++;2: iload_1 // 局部变量（1） -&gt; 栈顶3: iinc 1, 1 // 局部变量（1） + 16: istore_1 // 栈顶 -&gt; 局部变量（1） [i = 1]// int j = i++;7: iload_1 // 同上8: iinc 1, 1 // 同上 [i = 2]11: istore_2 // 栈顶 -&gt; 局部变量（2） [j = 1]// int k = i + ++i * i++;12: iload_1 // 所有的i [i = 2]13: iinc 1, 1 // ++i [i = 3]16: iload_1 // 第二个i [i = 3]17: iload_1 // 第三个i [i = 3]18: iinc 1, 1 // i++ [i = 4]21: imul // 3 * 322: iadd // 2 + 923: istore_3 // 栈顶 -&gt; 局部变量（3） [k = 11]24: return------------------------- 结果 --------------------------i = 4, j = 1, k = 11","link":"/2020/04/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Java%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"title":"Idea 常用快捷键","text":"熟悉快捷键后，能让你编写代码的速度大大提升噢 o(￣▽￣)ブ 加粗的是比较常用的 Ctrl删除光标所在行 或 删除选中的行：Ctrl + Y 剪切光标所在行 或 剪切选择内容：Ctrl + X 复制光标所在行 或 复制选择内容：Ctrl + C 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面：Ctrl + D 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围：Ctrl + W 显示一个类的子类（实现类）：Ctrl + H 显示最近打开的文件记录列表：Ctrl + E 方法参数提示显示：Ctrl + P 选择可重写的方法：Ctrl + O 选择可继承的方法：Ctrl + I 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号：Ctrl + / 关闭当前编辑文件：Ctrl + F4 执行 Bulid Project(构建项目) 操作：Ctrl + F9 窗口切换：Ctrl + Tab 删除光标后面的单词或是中文句：Ctrl + Delete 删除光标前面的单词或是中文句：Ctrl + BackSpace 移动光标到当前所在代码的花括号开始位置：Ctrl + [ 移动光标到当前所在代码的花括号结束位置：Ctrl + ] Alt **IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同：**Alt + 回车(Enter) 代码自动生成：Alt + Insert 切换当前已打开的窗口中的子视图：Alt + 左右方向键 Debug时查看值：Alt + F8 全屏(需自己设置快捷键)：Alt + D 多列输出：Alt + 鼠标左键(按住不放) Shift **取消缩进：**Shift + Tab 选中光标到当前行头位置：Shift + Home 选中光标到当前行尾位置：Shift + End 在打开的文件名上按此快捷键，可以关闭当前打开文件：Shift + 左键(单击) 滚动当前文件的横向滚动轴：Shift + 滚轮前后滚动 光标跳到右符号外：Shift + 符号(“ } ) &gt;) 开始新一行。光标所在行下空出一行，光标定位到新行位置：Shift + 回车(Enter) 隐藏当前 或 最后一个激活的工具窗口：Shift + esc Ctrl + Alt **格式化代码：**Ctrl + Alt + L 优化导入的类：Ctrl + Alt + O 光标所在行上空出一行，光标定位到新行： Ctrl + Alt + 回车(Enter) 打开 IntelliJ IDEA 系统设置：Ctrl + Alt + S 在外面套一层逻辑：Ctrl + Alt + T 生成 UML ：Ctrl + Alt + U Ctrl + Shift **根据输入内容查找整个项目 或 指定目录内文件：**Ctrl + Shift + F 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件：Ctrl + Shift + R 自动将下一行合并到当前行末尾：Ctrl + Shift +J 取消撤销：Ctrl + Shift + Z 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围：Ctrl + Shift + W 对选中的代码进行大 / 小写轮流转换：Ctrl + Shift + U 复制当前文件磁盘路径到剪贴板：Ctrl + Shift + C 弹出剪贴板：Ctrl + Shift + V 显示最近修改的文件列表的弹出层：Ctrl + Shift + E 代码块注释：Ctrl + Shift + / 展开所有代码：Ctrl + Shift + + 折叠所有代码：Ctrl + Shift + - 编辑器最大化：Ctrl + Shift + F12 自动结束代码，行末自动添加分号：Ctrl + Shift +回车(Enter) 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序：Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序：Ctrl + Shift + 后方向键 Alt + Shift 移动光标所在行向上移动：Alt + Shift + 前方向键 移动光标所在行向下移动：Alt + Shift + 后方向键 Ctrl + Shift + Alt打开当前项目设置：Ctrl + Shift + Alt + S 其他缩进：Tab 清屏：R 生成 Main()方法：psvm 生成 System.out.println()方法：sout 生成实例化对象：在方法后加.var 生成 Foreach()方法：在集合后加.for","link":"/2020/04/06/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/Idea%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"如何使用 Docker 部署项目","text":"部署方式有两种，可以先用 Dockerfile，再用 Docker Compose Dockerfile 打包，并把 Jar包移到 Linux 1mvn clean package -Dmaven.test.skip=true 创建 Dockerfile 1234567891011# 基于Java8FROM java:8# 复制jar包到容器COPY hello-spring-boot-thymeleaf-1.0.0-SNAPSHOT.jar app.jar# 暴露容器端口EXPOSE 8080 # 配置容器启动后的执行命令ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"] -Djava.security.egd=file:/dev/./urandom：作用是让 Tomcat 启动的更快。 构建自定义镜像 1docker build -t spring-boot:0.0.1 . 启动容器 1docker run --name spring-boot -d -p 8080:8080 spring-boot:0.0.1 Docker Compose 新建 docker-compose.yml 1234567version: '3.1'services: web: build: . ports: # 宿主机端口:容器端口 - \"8080:8080\" 守护进程启动 1docker-compose up -d","link":"/2020/04/06/%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/"},{"title":"Docker 编译 OpenJDK8","text":"共分七个步骤，拉取镜像、启动容器、进入容器、进入目录、检查依赖、进行编译，最后检查和验证即可 拉取镜像 1docker pull bolingcavalry/bolingcavalryopenjdk 启动容器 1docker run --name=compilejdk -idt bolingcavalry/bolingcavalryopenjdk:0.0.1 -i：让 Docker 分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上 -t：让容器的标准输入保持打开 -d：守护态运行 --name：为容器指定名称 进入容器 1docker exec -it compilejdk /bin/bash 进入目录 1cd /usr/local/openjdk 检查依赖 123456789101112131415161718192021./configure --with-debug-level=slowdebug====================================================A new configuration has been successfully created in/usr/local/openjdk/build/linux-x86_64-normal-server-slowdebugusing configure arguments '--with-debug-level=slowdebug'.Configuration summary:* Debug level: slowdebug* JDK variant: normal* JVM variants: server* OpenJDK target: OS: linux, CPU architecture: x86, address length: 64Tools summary:* Boot JDK: java version \"1.7.0_71\" Java(TM) SE Runtime Environment (build 1.7.0_71-b14) Java HotSpot(TM) 64-Bit Server VM (build 24.71-b01, mixed mode) (at /usr/java/jdk1.7.0_71)* C Compiler: gcc (GCC) 4.8.5 20150623 (Red Hat-11) version 4.8.5-11) (at /usr/bin/gcc)* C++ Compiler: g++ (GCC) 4.8.5 20150623 (Red Hat-11) version 4.8.5-11) (at /usr/bin/g++)Build performance summary:* Cores to use: 1* Memory limit: 962 MB* ccache status: not installed (consider installing) --with-debug-level=slowdebug：指定可以生成最多的调试信息 进行编译 1234567891011121314151617make all ZIP_DEBUGINFO_FILES=0 DISABLE_HOTSPOT_OS_VERSION_CHECK=OK CONF=linux-x86_64-normal-server-slowdebug----- Build times -------Start 2019-10-12 02:27:48End 2019-10-12 02:48:1000:00:40 corba00:00:36 demos00:02:38 docs00:05:16 hotspot00:00:50 images00:00:22 jaxp00:00:34 jaxws00:08:31 jdk00:00:39 langtools00:00:16 nashorn00:20:22 TOTAL-------------------------Finished building OpenJDK for target 'all' 检查和验证 123456cd /usr/local/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin &amp;&amp;./java -version====================================================openjdk version \"1.8.0-internal-debug\"OpenJDK Runtime Environment (build 1.8.0-internal-debug-_2019_10_12_02_27-b00)OpenJDK 64-Bit Server VM (build 25.0-b70-debug, mixed mode) 参考博客：极速体验编译openjdk8","link":"/2020/04/06/%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8/%E4%BD%BF%E7%94%A8Docker%E7%BC%96%E8%AF%91OpenJDK8/"},{"title":"十分钟带你熟悉 SVN","text":"十分钟带你熟悉SVN 本文分为项目经理篇、程序员篇，主要介绍了 SVN 的基本操作 项目经理篇 项目经理一般需要管理，SVN 服务端，首先让我们来创建一个服务端吧 服务端配置 创建一个数据仓库 1svnadmin create xxx 服务监听 1svnserve -d -r xxx -d：后台安全启动 -r：指定监听的仓库地址 三大指令 CheckOut：和服务器创建连接，并拉取数据到本地 Update：拉取数据到本地 Commit：提交本地数据到服务器 权限管理一般需要由项目经理，管理访问权限，需要配置三个文件： svnserve.conf：配置 SVN 12password-db = passwdauthz-db = authz passwd：配置用户名密码 1用户名 = 密码 authz：配置用户分组，以及权限 1234567891011[groups]分组名 = 用户名# 匹配所有路径规则[/]# admin组，可读可写@admin = rw# 匿名用户，只读* = r 自动开启服务监听 打开命令提示窗（管理员） 输入命令，创建服务 1sc create SVN binpath=\"xxx\\svnserve.exe --service -r \\\"xxx\\\"\" start=auto 配置钩子程序 打开 xxx\\bin\\hooks，里面都是钩子程序 将 post-commit.tmpl -&gt; post-commit.bat，其他的相同 修改文本内容 123SET SVN=\"E:\\JavaEE\\apache\\svn\\bin\\svn.exe\"SET DIR=\"E:\\Shop\"SVN update %DIR% PS：当程序员提交数据到 SVN服务器时，SVN 会自动提交到 Web服务器 程序员篇版本回退右击 -&gt; TortoiseSVN -&gt; Update to Revision -&gt; Show Log，选择你要回退的版本即可 版本冲突当两个程序员，提交同一个文件时，会出现版本冲突，在这种情况下，我们可以进行合并文件，再对文件进行修改，再次提交即可","link":"/2020/04/29/%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8/%E5%8D%81%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E7%86%9F%E6%82%89SVN/"},{"title":"带你了解位运算","text":"例子中，用的是 16 位二进制（2 字节），在计算机系统中，数值一律用补码表示 原码1：0000 0000 0000 0001 -1：1000 0000 0000 0001 反码1：0000 0000 0000 0001 -1：1111 1111 1111 1110 补码1：0000 0000 0000 0001 -1：1111 1111 1111 1111 负数补码的过程1234567// 首先展示负数的正数原码0000 0000 0000 0001// 取反1111 1111 1111 1110// 加 1// 所以 -1 的二进制表示就是1111 1111 1111 1111 总结正数的原码，反码，补码都一样 负数的原码，反码，补码不一样 位运算按位与(&amp;)只有当相应位上的数都是 1，该位才取 1，否则该位为 0。 123456// 将 1 与 -1 进行按位与(&amp;)运算0000 0000 0000 00011111 1111 1111 1111-------------------0000 0000 0000 0001// 1 &amp; -1 = 1 按位或(|)只要相应位上存在 1，那么该位就取 1，均不为 1，即为 0 12345678// 将 1 与 -1 进行按位或(|)运算0000 0000 0000 00011111 1111 1111 1111-------------------1111 1111 1111 1111// 补码为负，-1 取反1000 0000 0000 0001// 1 | -1 = -1 按位异或(^)只有当相应位上的数字不同才取 1，若相同，即为 0 1234567891011// 将 1 与 -1 进行按位异或(^)运算0000 0000 0000 00011111 1111 1111 1111-------------------1111 1111 1111 1110// 二进制负数转换十进制负数的过程// -11111 1111 1111 1101// 负数取反，符号不变，第一位表示符号，1 表示负数，0 表示正数1000 0000 0000 0010// 1 ^ -1 = -2 取反(~)每个位上都取相反值，1 变成 0，0 变成 1 123456789101112// 对 1 进行取反(~)运算，先取反，取反后得负数的补码，再减 1，取反0000 0000 0000 0001-------------------1111 1111 1111 1110// ~1 = -2// 对 -1 进行取反(~)运算，负数的补码进行取反1111 1111 1111 1111-------------------0000 0000 0000 0000// ~-1 = 0 左移(&lt;&lt;)进行左移运算，将一个数的二进制位全部向左移动若干位，正负数都补 0 12345// 对 1 左移两位（就相当于在右边加两个 0）0000 0000 0000 0001-------------------0000 0000 0000 0100// 1 &lt;&lt; 2 = 4 注意，观察可以发现，左移一位的结果就是原值乘 2，左移两位的结果就是原值乘 4。 右移(&gt;&gt;)进行右移运算，将一个数的二进制位全部向右移动若干位，正数补 0，负数补 1 12345// 对 1 右移两位（就相当于在左边加两个 0）0000 0000 0000 0001-------------------0000 0000 0000 0000// 1 &gt;&gt; 2 = 0 不带符号右移(&gt;&gt;&gt;)进行右移运算，正负数都补 0 12345// 对 -1 右移两位1111 1111 1111 1111-------------------0011 1111 1111 1111// -1 &gt;&gt;&gt; 2 = 1073741823 参考博客：位运算小结（按位与、按位或、按位异或、取反、左移、右移）","link":"/2020/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"title":"Docker-Compose 部署 MySQL&#x2F;Redis&#x2F;Nacos","text":"介绍如何用 Docker-Compose 分别部署 MySQL/Redis/Nacos 部署 MySQL 创建 docker-compose.yml 1234567891011121314151617181920212223version: '3.1'services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: 密码 command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql adminer: image: adminer restart: always ports: - 8080:8080 使用 Docker Compose 安全启动 1docker-compose up -d 部署 Reids 创建 docker-compose.yml 1234567version: '3.1'services: master: image: redis:5.0.6 container_name: redis ports: - 6379:6379 使用 Docker Compose 安全启动 1docker-compose up -d 部署 Nacos 官方文档：https://github.com/nacos-group/nacos-docker 直接克隆 Nacos 1git clone --depth 1 https://github.com/nacos-group/nacos-docker.git 使用 Docker Compose 安全启动 1docker-compose -f example/standalone-mysql.yaml up 默认账号密码为：nacos/nacos","link":"/2020/04/06/%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8/Docker-Compose%E9%83%A8%E7%BD%B2MySQL%E3%80%81Redis%E5%92%8CNacos/"},{"title":"告诉几个你不知道的 GitHub 小技巧","text":"解决卡顿 该方法同样适用 Docker Hub、Maven Repository 等网站 首先查询地址，输入github.com 把查到的 IP，放到 hosts 文件路径：C:\\Windows\\System32\\drivers\\etc\\hosts 高级搜索 in:name xx ：仓库名包含 xx in:readme xx：.md 文件中包含 xx language: xx：指定编程语言 stars:&gt; xx：star 的数量 删除历史记录1234567891011121314151617// 创建空分支git checkout --orphan latest_branch// 添加所有文件到新分支git add -A// 提交git commit -am \"commit message\"// 删除旧分支git branch -D master// 将新分支重命名为 mastergit branch -m master// 推送git push -f origin master","link":"/2020/04/06/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E5%91%8A%E8%AF%89%E5%87%A0%E4%B8%AA%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84GitHub%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"Ubantu 安装 Docker&#x2F;Docker Compose","text":"Ubantu 分别安装 Docker/Docker Compose 安装 Docker安装过程 使用脚本安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror AzureChinaCloud 验证安装是否成功，如果报 common docker not found，说明没有安装成功 1docker version 配置加速器 阿里云加速器：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 修改配置文件 12345678mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 验证配置是否成功 12345docker info======================== 出现了你的加速器地址，即为成功 ============================Registry Mirrors: https://xxxxxxxx.mirror.aliyuncs.com/ 安装 Docker Compose安装过程 使用 PIP 安装，你也可以在 GitHub 上克隆下来，不过速度嘛就不谈了 1sudo pip install -U docker-compose 如果出现如下输出，就代表成功 1234Collecting docker-compose Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded...Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress","link":"/2020/04/06/%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8/Ubantu%E5%AE%89%E8%A3%85Docker%E5%92%8CDocker-Compose/"},{"title":"Spring Cloud&#x2F;Dubbo 整合后启动报错","text":"这里出错主要还是没有熟练掌握 Maven导致的 首先看控制台报错，这里报的是非法状态异常，未找到配置或是无效的配置 1Injection of @Reference dependencies is failed;Injection of @Reference dependencies is failed; nested exception is java.lang.IllegalStateException: No application config found or it's not a valid config! Please add &lt;dubbo:application name=\"...\" /&gt; to your spring config. 往前在翻翻，从头看 12020-01-26 14:22:41.756 INFO 13636 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 8080 代表我的配置并没有生效，最后我在 pom.xml 找到错误 123&lt;!-- &lt;packaging&gt;pom&lt;/packaging&gt; --&gt;&lt;!-- 把 pom 改为 jar 即可--&gt;&lt;packaging&gt;jar&lt;/packaging&gt; 原因：由于我打包方式配置错误，导致未加载我的 xml，那我们一起来看看打包方式的区别吧 Maven 打包方式 pom：用于版本管理、父子关系 jar：默认该方式，用于工具类 war：用于 Web 项目的类","link":"/2020/04/06/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/SpringCloud%E4%B8%8EDubbo%E6%95%B4%E5%90%88%E5%90%8E%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"},{"title":"解决 Spring Security 常见问题","text":"以下问题都是由于粗心大意造成的/(ㄒoㄒ)/~~，同学，敲代码一定要仔细呀 未创建 Bean问题：无法创建 ‘springSecurityFilterChain’ 1No bean named 'springSecurityFilterChain' is defined. 解决： 首先看控制台的错误 发现启动没加载 spring-security.xml *找到 web.xml，把 CoutextLoaderListener 改为 ContextLoaderListener * 1234&lt;listener&gt; /* &lt;listener-class&gt;org.springframework.web.context.CoutextLoaderListener&lt;/listener-class&gt; */ &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 无效参数问题：非法参数，重复配置了 ‘/**’ 1java.lang.IllegalArgumentException: A universal match pattern (‘/**’) is defined before other patterns in the filter chain, causing them to be ignored. 解决： 首先看控制台的错误 123// 同时加载了两个配置，但我的源码里只有一个配置鸭common_cas/spring-security.xmlweb_center/spring-security.xml 再看项目的打包文件，果然有 spring-security.xml 输入如下命令 1mvn clean install 启动 tomcat ，一切正常 请求错误 开始我没有看这个警告，一般我只看 ‘Error’，(lll￢ω￢)，但就是因为不仔细看，才花了 1h 才发现这个错误 问题：提交 JSON 返回401，提示未授权 12WARN 5820 --- [io-9001-exec-10] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries; nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries at [Source: (PushbackInputStream); line: 3, column: 6]] 解决： 请求/user/login，提示未授权，很明显，后端没有对我授权 12345Status:401{ \"error\": \"unauthorized\", \"error_description\": \"Full authentication is required to access this resource\"} 于是 DEBUG，打断点，可是请求不到断点 这时怀疑没扫描到 Controller，给 Controller 新增方法吧 1234@GetMapping(\"demo\")public String demo() { return \"demo\";} OK，请求成功，再次 POST 请求还是返回 401，奇怪，试试关掉 csrf 1http.csrf().disable(); 再次请求还是返回 401，看了看 JSON 格式，好吧，原来 JSON 格式写错了 1234{ \"username\": \"pan176\" \"password\": \"123456\"} 你发现了吗？少了一个逗号，正确格式： 1234{ \"username\": \"pan176\", \"password\": \"123456\"}","link":"/2020/04/06/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/%E8%A7%A3%E5%86%B3SpringSecurity%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"title":"Hexo 搭建博客碰到的常见问题","text":"本人用的是 Hexo 3.1 上传报错问题：上传文件报错误 12warning: LF will be replaced by CRLF in xxx.The file will have its original line endings in your working directory 分析：Git 操作时，文件中的换行符有差别导致报错 解决：在克隆下的路径输入： 1234git rm -r --cached .git config core.autocrlf falsegit add .git commit -m '' 生成报错问题：输入命令call hexo d -g报错 12YAMLException:end of the stream or a document separator is expectedYAMLException:name of an alias node must contain at least one character at 解决：在你的 MarkDown 中添加头部信息，比如 123456---title: Hexo 生成报错data: 2019-11-28 14:38:14 permalink: Hexo 生成报错tags: 编程语言---","link":"/2020/04/06/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%A2%B0%E5%88%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"title":"记录本地部署 Nacos 踩过的坑","text":"最近在做个人网站，需要用到 Nacos，打包时碰到了几个坑，一起来看看吧 打包问题：在 PowerShell 中输入mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U 1[ERROR] Unknown lifecycle phase \".test.skip=true\". You must specify a valid lifecycle phase or a goal in the format &lt;plugin-prefix&gt;:&lt;goal&gt; or &lt;plugin-group-id&gt;:&lt;plugin-artifact-id&gt;[:&lt;plugin-version&gt;]:&lt;goal&gt;. Available lifecycle phases are: validate, initialize, generate-sources, process-sources, generate-resources, process-resources, compile, process-classes, generate-test-sources, process-test-sources, generate-test-resources, process-test-resources, test-compile, process-test-classes, test, prepare-package, package, pre-integration-test, integration-test, post-integration-test, verify, install, deploy, pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy. -&gt; [Help 1] 解决： 首先看控制台，提示我们无法识别 “.test.skip=true” 那么添加引号不就行了，如下 1mvn -Prelease-nacos '-Dmaven.test.skip=true' clean install -U 编译报错 解决了上面的问题，重新打包后又出现新的问题 1[ERROR] /E:/Code/nacos/naming/src/main/java/com/alibaba/nacos/naming/consistency/ephemeral/distro/DistroConsistencyServiceImpl.java:[92,26] 已在类 com.alibaba.nacos.naming.consistency.ephemeral.distro.DistroConsistencyServiceImpl中定义了变 量 loadDataTask 解决：找到 /E:.../DistroConsistencyServiceImpl.java，果然多了一个LoadDataTask，删除一个即可 1private LoadDataTask loadDataTask = new LoadDataTask();","link":"/2020/04/06/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/%E8%AE%B0%E5%BD%95%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Nacos%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"反编译","slug":"反编译","link":"/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","link":"/tags/IntelliJ-IDEA/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"SVN","slug":"SVN","link":"/tags/SVN/"},{"name":"二进制","slug":"二进制","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Nacos","slug":"Nacos","link":"/tags/Nacos/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Docker-Compose","slug":"Docker-Compose","link":"/tags/Docker-Compose/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"奇技淫巧","slug":"奇技淫巧","link":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"框架容器","slug":"框架容器","link":"/categories/%E6%A1%86%E6%9E%B6%E5%AE%B9%E5%99%A8/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"错误记录","slug":"错误记录","link":"/categories/%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"}]}